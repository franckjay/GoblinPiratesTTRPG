I have this new TTRPG. I am looking to create a Python based Agentic workflow where an LLM is the Game Master for this game. Here's what I need from you:

1. Create a main.py
2. Create a base GM agent class that will be inherited by the set of agents to be specified later
a. Inside the main.py, we will initialize (via raw input), the number of player characters, and then each PC will write out a short story and name for each PC. 
b. I envision that the main.py will have a while loop to control the flow of the game, something like while game_ongoing(optional_state): that checks after each loop of the gameplay phases if the game has finished. The termination reason for the state could be that all Player characters have died or the scenario has been completed.
3. For each player character story, a new agent (PlayerCharacterCreation) will spawn a PC with stats and an item that best match that PCs origin story (a goblin steeped in thievery will have very high cunning scores, not much else) by calling an LLM endpoint with a prompt. The prompt will take as input (origin_story, game_rules) and output a GoblinCharacter object 
4. Then iterate through each player, and have raw input from the player build the ship. The output of this function will be an object of class GoblinShip(). This need not call an LLM.
5. Finally in this initialization phase, we need to call an Agent. We can call this the NarrativeAgent(). Inputs at this stage can be simply the game rules, the Goblin character backstories into NarrativeAgent().create_initial_narrative(). The prompt to the Agent can be something like: "Create a simple scenario for a TTRPG that can be finished in 1 hour of gameplay. The RPG scenario should include a short backstory, an achievable goal that is humorous, fun, and PG-13 (light-hearted). part of the story should be a motivation for the players to achieve the goal (e.g., 'Why are the goblins doing this quest?')"

Now, still inside main.py, we want to iterate through each Phase of gameplay until an end state is achieved.
1. Sail Phase!  : No LLM agent needed for the user choices, as this is basically just the PCs making choices and rolling dice.  However, Probably will need to have a TargetShip() object that can be optionally updated via rolling 2d6 to generate the ship difficulty. The TargetShip() will be created by calling a BuildTargetShipAgent(ship_difficulty: str, current_narrative: str). The ship_difficulty is the result of the 2d6 roll, and the agent will create a short description and backstory of the target ship that fits the current_narrative string ("Is this a Kobold Kruise with lots of loot? Is it a menacing group of Nautical Otter Navy crew that holds the secret to the next stage of combat?")
2. Raid Phase! This will involve two subphases: Ship to Ship combat, Boarding Combat.
a. Ship To Ship: Iterate through each player character. They will input some narrative into what they plan on doing to successfully attack the opposing ship and roll a set of dice. In addition, a set of 2d6 will be rolled by the opposing ship to counter with Speed, Trickery, or Counterattack. These will be fed into the LLM agent for Ship to Ship combat: ShipCombatAgent(overall_story_narrative: str, attacking_ship: GoblinShip, target_ship: TargetShip(), game_rules: str). The LLM prompt for this Agent will read something like: f"Based on the backstory of this target ship, {target_ship.narrative}, current battle narrative (narrative, if any = self.current_battle_narrative) and a roll of {2d6_roll}, construct a plausible outcome of this round of combat. The player characters have decided to try to: {overall_story_narrative}. A very strong roll by the target ship and choice of either Speed, Trickery, or Counterattack could result in the target ship escaping the attackers. If this the case, clearly state the word 'escaped' in the output. Otherwise, explain the outcome of the player characters efforts in a fun and amusing style that befits the rules."
b. Once the LLM has returned a result, first check to see if the target ship has escaped. If it has, then set a variable for the TargetShip.escape to True to exit combat. Otherwise, check to see how much, if any, damage the crew has wrecked on the TargetShip. If the Hull integrity is 5 or fewer of the target ship, TargetShip.boardable = True. Then do a token match to see if the opposing ship Counterattacked and subtract off a random number of Hull Points from GoblinShip. At the end of the LLM agents step, return the new narrative to the PCs and append the LLM output to the self.current_battle_narrative so that the agent can understand what happened in subsequent rounds of battle.
b. Boarding Combat: once the enemy ship becomes boardable, have a BoardingCombatAgent(pc_story_narrative: str, attacking_ship: GoblinShip, target_ship: TargetShip(), game_rules: str) describe the initial scene in a fun and fanciful way. For each player character, we want to have a raw input of what that player intends to do narratively and then roll a 2d6. Perhaps the player order can be shuffled randomly. Each player round of combat will be handled with an LLM that will output the narrative based on the die roll and the rules in Boarding Combat. So something like BoardingCombatAgent.player_turn(dice_roll: int, character_input: str, goblin: GoblinCharacter,  target_ship: TargetShip()). This will happen iteratively UNTIL the DS of the target ship is at or below 0. The LLM will craft a simple, fun response based on the dice roll and the players intent.